\section{Hypergraph Ontologies} 
\p{Hypergraphs --- along with 
structures that can be modeled via hypergraphs, 
such as Conceptual Spaces --- are an improvement 
on Semantic Web data formats and schema, addressing 
the limitations of a paradigm devoted to modeling 
complex information via first-order logic and 
non-nested graphs, with no notion of scoping or 
locality.\footnote{These are familiar critiques, but 
laid out with particular thoroughness by the 
Conceptual Space community, as 
we will discuss in Chapter 7.}
At the same time, a lot of effort has been extended 
building technologies to integrate heterogeneous 
data spaces via the Resource Description Framework 
(\RDF{}) and \RDF{} ontologies.  In radiology, for 
example, attempts to better incorporate clinical 
and outcomes data are centered on ontologies such 
as \RadLex{}, \ViSion{}, and \SeDI{}, which we 
discussed in Chapter 2.  As a result, the important 
consideration is how to employ hypergraphs as an extension 
to the Semantic Web when warranted while preserving 
the virtues (and interoperating with) 
conventional \RDF{} ontologies.
}

\p{The idea that hypergraphs \textit{extend} 
but do not \textit{replace} \RDF{} and the 
Semantic Web implies that hypergraph schema 
are extensions of (but not substitutes for) 
\RDF{} ontologies --- which in turn 
yields the notion of \textit{hypergraph 
ontologies}.  In a conventional \RDF{} ontology, metadata is primarily 
associated with graph nodes and edges.  In particular, 
nodes are referenced to Uniform Reference Identifiers 
(\URI{}s), such as web addresses, and edges are labeled 
with concepts formally defined in one or more ontologies.  
Concepts which are used to annotate graph-edges, and which are 
given a fixed meaning in some controlled vocabulary, are 
often called \q{properties.}  One special \q{is-a} property 
is often used to connect nodes with concepts that 
classify entities into one of many categories defined 
in an ontology, often called \q{classes.}  As such, most 
\RDF{} ontologies are primarily composed of 
\textit{classes} and \textit{properties}, each assigned 
a unique label.  The purpose of metadata for a given graph 
is then to link nodes to classes (for example, specifying 
that one node represents a clinical trial and the second 
represents a patient), and furthermore to link edges with properties 
(for example, specifying that a patient-node is connected 
to a trial-node in that the patient is \textit{enrolled in} 
the trial).
}

\p{Hypergraph ontologies are similar to conventional 
\RDF{} ontologies in that they likewise provide 
constraints and metadata for graphs.  However, 
hypergraph ontologies are more complex because hypergraphs 
are likewise more complex than ordinary graphs.  In particular, 
hypergraphs have different layers of structure:  
whereas \RDF{} nodes are intended to represent a 
single concept or value (such as a number, date, 
personal name, or \URL{}), a \textit{hypernode}, within a 
graph, typically encompasses multiple pieces 
of information inside it (often called \textit{hyponodes}, 
\textit{projections}, \textit{inner elements}, 
\textit{roles}, or just \textit{nodes}).%
\footnote{\raggedright{}%
The term \q{roles} is used by Grakn.ai 
(see \dhref{https://dev.grakn.ai/docs/schema/concepts}); 
\q{projections} is used by HyperGraphDB (see 
\dhref{http://www.hypergraphdb.org/?project=hypergraphdb&page=RefCustomTypes}); 
\q{inner entity} is used by the biointelligence project 
\cite{ToniFarley}, 
where the corresponding notion of \q{external entity} 
refers to what in other contexts might be called 
other hypernodes linked to a given hypernode via hyperedges.}  
In general, when analyzing hypergraphs it is necessary to 
distinguish at least two \q{tiers} of nodes, 
\textit{hypernodes} and \textit{hyponodes}, such that 
hyponodes are contained within hypernodes.  As a result, 
hypergraph ontologies need a corresponding distinction 
for node and edge annotations: insofar as nodes are 
categorized via classes, and edges via properties, 
it is necessary to stipulate whether these classifications 
apply to hypernodes, hyponodes, or some combination of the two.
}

\p{A further complication arises because, 
even though hypergraphs represent nested or hierarchical structures,  
these hierarchies are often partial or overlapping. 
For example, a patient is \textit{part of} a 
clinical trial, but a patient is also included in 
other collections as well; for instance, a patient 
may be enrolled in a specific health plan 
(for insurance coverage).  One technique for modeling 
overlapping hierarchical data via hypergraphs is to 
employ \q{proxies,} which are digital identifiers encoding a 
multi-faceted concept into a single value that can be 
part of a hypernode (proxies are similar to 
\q{foreign keys} in \SQL{}).  Therefore, each patient, represented 
by its own hypernode, has an identifier which can be a 
proxy-value for the patient; for example, a value 
assigned to a hyponode becomes included 
in the hypernode encoding the list of patients enrolled 
in a clinical trial, or in the hypernode 
encoding the list of patients enrolled 
in a specific health plan.  Hypernodes can then be linked to 
other hypernodes by virtue of proxies (e.g., the 
trial-to-patient connection), and also by 
virtue of overlap (e.g., the set of all patients 
both enrolled in a given clinical trial \textit{and} 
enrolled in a given health plan).
}

\p{In sum, compared to \RDF{} --- where there is one 
single sort of node-to-node relationship, based on 
whether or not an edge exists between nodes and 
how this edge is labeled --- hypergraphs are more 
flexible/expressive because they have 
multiple genres of node-to-node relationships: 
the relation between hypernodes and their inner 
hyponodes; between hypernodes and one another; 
between hyponodes in different hypernodes; 
and variations on each of these relation-types 
wherein relations are defined indirectly through 
proxies.  Moreover, in addition to hypernodes 
and hyponodes, hypergraphs afford additional 
levels of detail, such as \textit{frames}, 
\textit{channels}, and \textit{axiations}.
All of these details provide different 
\q{sites} where hypergraph annotations and 
metadata may be defined.\footnote{This means that 
formats for describing hypergraph ontologies 
have to be more expressive than \sRDF{} ontologies, 
because \sRDF{} ontologies need only to classify 
metadata as node-annotations or edge-annotations; 
by contrast, hypergraph ontologies need to distribute 
annotations among multiple sites of graph structure.}
}

\p{An additional distinction within the Semantic Web 
is the contrast between \textit{reference ontologies} and 
\textit{application ontologies}.  In general, \textit{reference 
ontologies} are general-purpose schema intended to 
establish conventions shared by many different applications, 
to ensure that a large collection of data-producing software 
in a given domain is interoperable.  By contrast, 
\textit{application ontologies} are narrower in scope 
because they are more tightly integrated into applications that 
directly send and receive data.  Ontologies 
of either variety are used by software to interoperate 
with other software: so long as two applications are 
using the same ontologies, it is possible to 
ensure that one application can understand the 
data produced by a second, and vice-versa.  
However, such inter-operability is only potential; 
it is the responsibility of programmers to 
actually implement code which produces and/or 
consumes data that conforms to the relevant 
ontology specifications.  In general, application 
ontologies are structured in such a way that 
these concrete implementations are more straightforward 
to produce, compared with reference ontologies.  
Reference ontologies offer little guidance to 
developers \visavis{} how to directly support the 
ontology within application code.  Conversely, 
application ontologies more rigorously describe the 
data structures which applications must implement 
in order to properly manipulate data that is structured 
according to the specifications of the ontology.
}

\p{Within data mining and image analysis, hypergraph 
models are used in different ways for different 
algorithms.  In the context of Covid-19 radiology, 
\cite{DonglinDi} (which we cited last chapter) 
describes an algorithm for assessing the 
probability of SARS-CoV-2 infection from chest \CT{} scans, 
where hypernodes represent high-dimensional 
vectors (191 dimensions overall) and hyperedges 
represent k-nearest-neighbors; here each hypernode 
represents an entire image, mapped to a 191-dimensional 
feature-vector.  In contrast, other image-analysis 
methods use hypernodes to designate smaller segments 
\textit{within} the image, where hyperedges 
designate geometric adjacency and/or feature-space 
similarities.  Whatever the algorithm, hypergraph 
analyses would employ a hypergraph library 
to store preliminary data for analysis and/or for 
serialization within a data set.  One benefit of a 
Hypergraph Application Ontology is therefore that 
these data structures used internally to implement 
analytic methods can be directly expressed within 
the ontology, whereas \RDF{} ontologies can only 
model hypergraphs indirectly.
}

\p{Although it is theoretically possible to encode 
data directly via \RDF{} graphs, it is far more 
common for applications to employ tabular and/or 
hierarchical formats for data sharing, 
such as spreadsheets, Protocol Buffers,
\XML{}, or \JSON{}.  As a result, the role of ontologies 
for constraining data structures (so that they adhere 
to common standards) is indirect.  It is useful to 
remember that ontologies are, at their most basic level, 
Controlled Vocabularies; as such, ontology constraints often 
amount to stipulating a set of acceptable terms for a data 
value, column header, or annotation.  For a trivial example, 
our calendar recognizes 12 month names and 7 day names, 
which constrain the set of values permissible for \q{month} 
and \q{day} within a calendar date.  These terms are 
so commonplace that a \q{date ontology} is unnecessary, 
but in scientific or technical domains it becomes 
necessary to define vocabularies of allowable 
names or labels for specific data fields that 
representing some scientific value or measurement.  For instance, 
the Ontology of Vaccine Adverse Events  
\cite{EricaMarcos} provides a nomenclature for use in Adverse Events Reporting, 
so that researchers or clinicians can describe symptoms via canonically 
recognized terms rather than through informal 
text descriptions.  In general, ontologies constrain 
data sets by stipulating that particular individual 
values within the overall data collection have names or descriptions 
whose associated set of possible values is prescribed \textit{a priori} 
by the applicable ontology.  However, the relationship between 
ontologies and concrete data sets must itself be 
documented, which is where application ontologies 
can become relevant --- application ontologies provide 
a bridge between reference ontologies and the 
applications which use them (along with the data 
generated and shared by those applications).
}

\p{In order to preserve the benefits of \RDF{} 
ontologies --- while also addressing those lacunae 
which make the Semantic Web \q{not (really) semantic} 
--- hypergraph ontologies need to model constraint 
schema on hypergraph constructions (which have 
significantly more parameters of structuration 
than \RDF{} graphs) while also connecting 
these schemas to the Controlled Vocabularies 
and logical axioms of Semantic Web (particularly 
\OWL{}) ontologies.  There are as such 
several areas of detail within hypergraphs 
where links to \RDF{} ontologies may be 
drawn, which are outlined here:\footnote{A 
full explanation of these concepts and terminology 
depends on an in-depth treatment of hypergraph 
type theory, which is outside the scope of 
this proposal.
}

\begin{description}[style=unboxed]

\item[Hypernodes' Cocyclic Type Structure]
One of the central principles of hypergraph data modeling 
is the use of \textit{hypernode types} to 
specify what sort of information is necessarily 
associated with a hypernode.  In particular, 
a hypernode encompasses multiple hyponodes, 
each with their own type.  These hyponodes 
represent information in some sense 
\q{contained within} or \q{tightly connected  
to} a hypernode (whereas data less canonically 
associated with each hypernode would, in 
general, be asserted via hyperedges rather than 
via hypernode/hyponode containment).  In order 
to ensure that hypergraphs are predictably 
organized, hypernodes cannot have arbitrary 
collections of hyponodes, but must instead 
be aggregates of hyponodes which are assembled 
according to a schematic pattern, defined in 
terms of hyponode types.  For maximum generality, 
a hypergraph type system should allow hyponode-type 
patterns to be as flexible as possible without 
introducing a need for metadata asserted at the 
level of individual hypernodes rather than hypernode 
types; this motivates the idea we proposed 
above of a \q{cocyclic} 
type system which is minimally constrained 
(but not unconstrained).\footnote{Becase a 
pattern of hyponode types is \q{cocyclic} 
if the type-sequence includes a (possibly empty) 
tuple of types with no requisite pattern 
(called the \q{precycle}) followed by a 
repeatable type-tuple, cocyclically typed 
hypernodes can represent expandable 
data structures such as lists, stacks, 
queues, deques, and dictionaries.  A typical 
hypernode type may then indirectly include multiple 
collections-types via proxies.}   
When translating \RDF{} ontologies to hypergraph 
schema, accordingly, one consideration is whether 
edge-requirements are sufficiently ubiquitous 
in some context (e.g. with respect to some 
\textbf{rdf:class}) that these edges should 
be translated to hypernode/hyponode inclusions, 
and then to define a pattern of hyponode types 
for the corresponding hypernode type (the 
alternative is to retain the edges 
as links between \textit{hyper}-nodes if 
they are \textit{sometimes} but not \textit{always} joined.

\item[Roles, Projections, and Dimensional Annotations]
A hypernode type provides a schema defining a 
sequence of hyponode types; it is sometimes 
said that the hypernode \q{projects onto} that 
space of hyponode types.  This projection is 
minimally characterized by hyponode types, 
but some hypergraph systems allow the 
projection to be \textit{annotated}, introducing 
additional metadata that constrain 
(or augment the expressive power of) the 
enclosing hypergraph.  Annotations can 
define scales/units/levels of measurement, 
probability distributions, situational roles, 
and other details lending semantic grounding 
to the data-field encapsulated by a hyponode.  
This metadata can then be a vehicle for 
translating \RDF{} class constraints to 
hypergraph schema. 

\item[Semantic Nominal Dimensions]
The most direct translation of 
Controlled Vocabularies to a hypergraph context 
is often that of constraining the space 
of variation for one specific project to 
a set of allowable terms.  In the typical 
case, a hyponode type encapsulates a 
nominal set of values (i.e., an enumeration), 
so any hypernode including that type as one 
of its projects is constrained by the 
labels registered in the vocabulary 
(a related formulation replaces 
non-hierarchical vocabularies with 
\textit{taxonomies}, where some labels 
are treated as more or less granular 
variants of others).

\item[Dimension Aggregates, Domains, and Conceptual Spaces]
Conceptual Spaces can be modeled in the 
hypergraph context by noting that hyponode 
projections are sometimes interdependent: 
dimensions tend to aggregate into semantically 
related groups (like \textit{latitude} and 
\textit{longitude} as geographic markers).  
In Conceptual Space models, accordingly, 
projections are split into two 
levels --- \textit{dimensions} and 
\textit{domains} --- while other 
dimensional-analytic constructions 
(such as scales and units of measurement) are 
carried over (see \cite{RaubalAdams}).  
Conceptual Space Theory also then introduces 
concepts of fuzzy logic or \q{convexivity} 
(according to different metrics) to simulate 
patterns in human 
conceptualization.  We will 
discuss Conceptual Spaces in greater detail 
over the next few chapters.
  
\item[Probabilistic, Temporal, and Overlapping Hypergraphs]
Other forms of metadata constrained via ontologies 
can be expressed in terms of annotations 
defining weights or probabilities on 
hypernodes and/or hyperedges.  One example is 
the juxtaposition of alternative markup hierarchies, 
in the context of hypergraph representations for 
Concurrent Markup languages such as \TAGML{} 
\cite{BleekerEtAl}.  
Numeric edge-annotation can represent 
weights (e.g., provide measures of the degree 
of uncertainty in the edge's relation actually 
obtaining), but constructions similar to 
weights have other sorts of applications.  
For instance, edge-annotations can be measures 
of time-spans, allowing hypergraphs to 
describe \q{entity-event models.}\footnote{See 
\bhref{https://allegrograph.com/consulting/entity-event-knowledge-graphs/}.}

  
\item[Proxies, Inverted Proxies, and Double-Inverted-Proxy Constructions]
As described earlier, hypernodes can assert \q{containment} of 
other hypernodes by containing a \textit{hyponode} which 
\textit{proxies} the second hypernode.  
An \textit{inverted proxy} connection is therefore 
the mirror-image of this assertion 
(which may or may not be formally recognized 
by the hypergraph).  A \textit{double-inverted-proxy} 
connection is accordingly the relation obtaining 
between two hypernodes which are both proxied by 
one third hypernode (using the earlier example 
of proxies, the fact that two patients 
are enrolled in the same clinical trial).  
Many graph connections identified in a 
Semantic Web context (e.g., by \SPARQL{} queries) 
are likely to translated to double-inverted proxies 
in a hypergraph context.  
\end{description}

In general, these hypergraph constructions represent 
sites for asserting constraints that 
(for \RDF{} ontologies) would be defined on 
classes or properties; they are therefore 
a natural scaffolding for translating \RDF{} ontologies 
to hypergraphs.  Such a translation 
mechanism allows existing ontologies 
--- which may play a valuable role 
in specifying protocols for workflows 
and data-sharing between software components  
--- to be reused in a hypergraph modeling environment.
}

\p{As illustrated by \CaPTk{} (discussed in Chapter 2), 
multi-application workflows 
are characterized both by the data which is 
transferred between applications and by the 
operations which connect the two applications 
--- that is, the procedures enacted by 
each application when they become operationally 
linked.  As a preliminary model, we can identify 
two stages of operational connection between 
an already-running application (which may be 
called the \textit{primary} component) 
and a second application launched by the primary 
(which may be called the \textit{peer} component).  
The first stage occurs when the primary component 
launches the peer component, and is characterized 
by two operational sequences: procedures enacted 
by the primary prior to this launch, and procedures 
enacted by the peer subsequent to the launch.  
A second stage occurs when the peer component 
has completed its actions, and sends data back 
to the primary component, which again involves two 
operational sequences: procedures enacted by the 
peer prior to the transfer, and procedures enacted by the 
primary subsequent to the transfer.  Fully describing 
the procedural workflow therefore entails specifying 
four operational sequences: primary, then peer, 
during the launch stage; and peer, then primary, 
during the transfer stage.  A schema describing 
the operations performed during these four sequences 
can be called a \textit{procedural ontology}.
}

\p{Consequently, rigorous models of multi-application networks 
should \textit{synthesize} information about data structures 
(the type of information shared between application-points) 
with information about procedural workflows 
(describing operational sequences prior to 
the launch and transfer stages of a multi-application linkage).  
The synthesis of this structural and procedural information 
can be called a \textit{procedural application ontology}.
}

\p{One area where \q{procedural} Ontologies would differ 
from conventional Ontologies on the Semantic Web 
is that Ontologies in the former sense seek to 
characterize procedures (which by nature are digital 
artifacts) as well as objects (whether concrete 
or abstract).  Of course, the Semantic Web notion 
of \q{object} is highly general, and certainly encompasses 
a broad range of abstract entities, including anything 
existing in the context of computer software and 
source code.  So procedures as objects --- or the 
analogous equivalence in the programming context, 
\q{functions as values} --- can certainly be modeled 
with some degree of precision in a Semantic Web 
context.  The difference between Semantic Web 
and \q{Hypergraph} Ontologies is not absolute, 
but it involves shades or degrees of emphasis.  
In the context of Hypergraph Ontologies, we 
can say that an \textit{intrinsic} detail of computational 
data structures is that many data-types are collections 
of values which instantiate other data types --- that is, containers which contain 
multiple instances of other types, and these containers 
can vary in size as values are added or removed.  Different 
types of containers add or remove values in different ways: 
for instance, many containers are ordered, and restricted so that 
new values can only be placed at the end (or, alternatively, 
at the beginning) of the list.  For these sorts of 
data structures, modeling procedures governing how the 
structures may change state (e.g., how lists may acquire 
new values) is an intrinsic dimension of modeling the 
semantics of the data structures themselves.  This interconnectedness 
between data structures and procedural requirements is not 
entirely outside the representational scope of the 
Semantic Web, but nor is it the primary conceptual 
focus of Semantic Web Ontologies.  However, the 
interconnectedness of data structures and the 
procedures which operate on them \textit{is} an 
intrinsic concern of programming language type 
theory.  A thorough foundation for reasoning 
about data-sharing therefore calls for some form 
of hybrid analysis encompassing both Semantic Web 
Ontologies and type theory, as we will briefly review in the next subsection.
}

%\p{}

%\p{}

%\p{}

